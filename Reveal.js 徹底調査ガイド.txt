Reveal.js 完全ガイド：基本原則から高度なプレゼンテーションマスターまでPart I: 基礎と最初の一歩第1章: Reveal.js フレームワーク入門Reveal.jsとは？ HTMLベースプレゼンテーションの哲学Reveal.jsは、オープンソースのHTMLプレゼンテーションフレームワークです 1。Webブラウザさえあれば、誰でも無料で美しくインタラクティブなスライドデッキを作成できるこのツールは、HTML、CSS、JavaScriptといったオープンなウェブ技術を基盤としています 3。その中心的な哲学は「コードとしてのプレゼンテーション」です。従来のWYSIWYG（What You See Is What You Get）エディタとは異なり、コンテンツと構造をマークアップ言語で直接記述することで、プレゼンテーションのあらゆる側面に対する完全な制御、柔軟性、そしてプラットフォームからの独立性を実現します 4。このアプローチは、特に技術的な内容を扱う開発者や研究者にとって、計り知れない利点をもたらします。このフレームワークはHakim El Hattab氏によって作成され、活発なコミュニティによって継続的に開発されています 1。主要な機能と性能の概要Reveal.jsは、プレゼンテーション作成のための強力な機能群を標準で備えています 1。以下にその主要な機能を挙げます。ネストされたスライド（垂直スライド）: 主要な水平方向のスライドの中に、補足的な情報を垂直方向に配置できます。Markdownサポート: HTMLよりも簡潔なMarkdown記法でスライドコンテンツを迅速に作成できます。Auto-Animate: 隣接するスライド間で一致する要素を自動的にアニメーションさせ、滑らかな遷移を実現します。PDFエクスポート: プレゼンテーションをPDF形式で出力し、配布やオフラインでの閲覧を容易にします。スピーカーノート: 発表者のみが見ることができるノート機能で、タイマーや次のスライドのプレビューも表示されます。LaTeXサポート: MathJaxやKaTeXプラグインを通じて、美しい数式をスライド内に埋め込めます。シンタックスハイライト: highlight.jsを利用して、コードブロックを言語に応じて美しく色付けします。豊富なAPIとプラグイン: JavaScript APIを通じてプレゼンテーションの挙動を細かく制御したり、プラグインで機能を拡張したりすることが可能です。これらの機能に加え、タッチデバイスに最適化された設計により、スマートフォンやタブレットでも快適な操作が可能です 1。比較分析: Reveal.js vs. 従来型ツール（PowerPoint, Keynote, Google Slides）Reveal.jsとPowerPointのような従来型ツールとの選択は、単なる機能比較ではなく、プレゼンテーション作成における哲学の違いを理解することにあります。Reveal.jsの利点:完全な制御とカスタマイズ性: HTML、CSS、JavaScriptを直接編集できるため、デザインやインタラクションの限界がありません 4。バージョン管理: プレゼンテーションがテキストファイル（HTML, Markdown）であるため、Gitなどのバージョン管理システムと非常に相性が良く、変更履歴の追跡や差分の確認が容易です 4。Markdownによる迅速なコンテンツ作成: 特に技術者にとって、Markdownの簡潔さはコンテンツ作成の効率を劇的に向上させます 4。プラットフォーム非依存: 最新のWebブラウザが動作するあらゆるデバイス（Windows, macOS, Linux, タブレット）で一貫した表示が保証されます 4。無料でオープンソース: コストがかからず、コミュニティによって継続的に改善されています 4。Reveal.jsの課題点:技術的な前提知識: HTML、CSS、JavaScriptの基本的な知識が必要です 5。初期設定の複雑さ: 従来型ツールに比べ、最初のセットアップに手間がかかる場合があります 10。共同編集の難易度: Google Slidesのようなリアルタイム共同編集機能はなく、非技術者との共同作業にはGitなどの知識が求められます 10。これらの比較から導き出されるのは、Reveal.jsが全てのプレゼンテーションツールを置き換えるものではないということです。PowerPointやGoogle Slidesが提供する「使いやすさ」や「共同編集の容易さ」と、Reveal.jsが提供する「完全な制御」「バージョン管理」「高度なインタラクティビティ」との間には明確なトレードオフが存在します。Reveal.jsは、特に技術的な内容を正確かつ美しく伝えたいと考えるプレゼンターにとって、比類なき能力を発揮する専門的なツールと言えます。Reveal.jsのエコシステム: コアライブラリ、エディタ、ツールReveal.jsのエコシステムは、中核となるreveal.jsライブラリ 2 を中心に広がっています。コーディング不要でReveal.jsプレゼンテーションを作成したいユーザー向けには、同じ開発チームが提供する商用のビジュアルエディタSlides.comが存在します 1。さらに、本レポートで後述するプラグインアーキテクチャ 12、Quarto 13 やR Markdown 14 といったデータサイエンスツールとの連携、そしてVS Code拡張機能 15 のような開発者向けツールも、この強力なエコシステムの一部を形成しています。第2章: インストールとプロジェクト設定Reveal.jsを始めるには、用途や技術レベルに応じて複数のインストール方法が用意されています。ここでは主要な5つの方法を詳述します。方法1: Basic Setup（直接ダウンロード）これは最も手軽に始める方法で、ビルドツールや依存関係のインストールは一切不要です 16。GitHubリポジトリから最新版のZIPファイルをダウンロードします 16。ダウンロードしたファイルを解凍し、中にあるindex.htmlをテキストエディタで開きます。index.html内のサンプルコンテンツを自身のプレゼンテーション内容に書き換えます。編集したindex.htmlファイルをWebブラウザで直接開きます。この方法は非常にシンプルですが、重大な制約があります。外部のMarkdownファイルを読み込む、スピーカーノート機能を使うといった多くの高度な機能は、ローカルWebサーバー経由でファイルを提供しないと動作しません 16。これは、ブラウザのセキュリティポリシーが、ローカルファイルシステム (file://プロトコル) から他のローカルファイルへの非同期リクエスト（AJAX）をブロックするためです。したがって、この方法は簡単なテストや一度きりのプレゼンテーションには適していますが、本格的な開発には不向きです。方法2: Full Setup（Node.js & npm）開発用途で最も推奨されるのがこの方法です 16。ローカル開発サーバーが付属しており、全ての機能を利用できます。Node.jsのインストール: 公式サイトからNode.js (バージョン10.0.0以降) をインストールします 16。リポジトリのクローン: ターミナルで以下のコマンドを実行し、Reveal.jsのソースコードを取得します。Bashgit clone https://github.com/hakimel/reveal.js.git
依存関係のインストール: ダウンロードしたディレクトリに移動し、npm installを実行します。これにより、開発に必要なパッケージがインストールされます 3。Bashcd reveal.js
npm install
開発サーバーの起動: npm startコマンドを実行すると、開発サーバーが起動し、プレゼンテーションがhttp://localhost:8000で表示されます 18。このサーバーはファイルの変更を監視し、自動的にブラウザをリロードする機能（ライブリロード）も備えているため、効率的な開発が可能です。方法3: npmパッケージとしての利用既存のWebアプリケーションにReveal.jsを組み込んだり、ViteやWebpackのようなモダンなビルドツールと共に使用したりする場合に適した方法です 16。インストール: プロジェクトのディレクトリで以下のコマンドを実行します。Bashnpm install reveal.js
ESモジュールとしてインポート: JavaScriptファイル内でReveal.jsをインポートして初期化します 8。JavaScriptimport Reveal from 'reveal.js';
import Markdown from 'reveal.js/plugin/markdown/markdown.esm.js';

let deck = new Reveal({
  plugins: [ Markdown ]
});
deck.initialize();
CSSのインクルード: reveal.css（コアスタイル）とテーマ用のCSSファイル（例: black.css）を、プロジェクトのHTMLファイルに手動でリンクするか、ビルドプロセスに含める必要があります 16。方法4: CDNを利用したセットアップローカル環境に何もインストールせず、手軽に利用を開始する方法です 4。必要なファイルをCDN (Content Delivery Network) から直接読み込みます。この方法は、簡単なプロトタイピングや、CodePen 22 のようなオンラインエディタでプレゼンテーションを共有する際に非常に便利です。ただし、常にインターネット接続が必要であり、特定のバージョンを固定して管理することがローカルでのpackage.json管理に比べて煩雑になる可能性があります。以下は、CDNを利用した基本的なindex.htmlのテンプレートです。HTML<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>CDN Presentation</title>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4/dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4/dist/reveal.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4/dist/theme/black.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <section>Slide 1</section>
      <section>Slide 2</section>
    </div>
  </div>
  <script src="https://unpkg.com/reveal.js@4/dist/reveal.js"></script>
  <script>
    Reveal.initialize();
  </script>
</body>
</html>
方法5: Dockerによるコンテナ化開発開発環境の差異をなくし、再現性を高めるための方法として、コミュニティが提供するDockerイメージを利用する方法があります 23。このアプローチの利点は、ローカルマシンにNode.jsやnpmを直接インストールする必要がなく、プロジェクトリポジトリをクリーンに保てること、ビルドが高速化されること、そしてフレームワークのアップデートがDockerイメージのバージョンを上げるだけで済むことなどです 23。基本的な利用法は、docker runコマンドでコンテナを起動し、ローカルのMarkdownファイルが含まれるディレクトリをコンテナ内にマウントすることです。これにより、環境構築の手間が大幅に削減されます 23。表: インストール方法の比較方法主な用途利点欠点必要なものBasic Setup初心者、一度きりの利用最もシンプルで迅速機能制限あり（サーバー必須機能が使えない）WebブラウザFull Setup本格的な開発、全機能の利用全機能利用可、ライブリロード対応Node.js環境の構築が必要Node.js, npm, Gitnpm Dependency既存のWebアプリへの統合モダンな開発フローとの親和性ビルドツールの知識が必要Node.js, npm, ビルドツールCDNプロトタイピング、オンラインでの利用インストール不要、手軽常時インターネット接続が必要、バージョン管理が煩雑Webブラウザ、インターネット接続Dockerチーム開発、環境の統一高い再現性、ローカル環境を汚さないDockerの知識が必要Docker第3章: Reveal.js プレゼンテーションの構造コアとなるHTML構造の理解Reveal.jsプレゼンテーションは、特定のHTML階層構造に従う必要があります。この構造が、フレームワークがスライドを認識し、制御するための基礎となります 3。<div class="reveal">: プレゼンテーション全体をラップする最も外側のコンテナです。<div class="slides">: 全てのスライドを直接内包するラッパーです。<section>: 個々のスライドを表す要素です。この要素を必要な数だけ繰り返すことで、プレゼンテーションが構成されます。この.reveal >.slides > sectionという階層は必須です。最初のスライド作成: 水平・垂直ナビゲーションプレゼンテーションの基本的な流れは、<section>要素を並べることで作られます。これが水平方向のスライドシーケンスとなります 19。HTML<div class="reveal">
  <div class="slides">
    <section>最初のスライド</section>
    <section>2番目のスライド</section>
  </div>
</div>
Reveal.jsの大きな特徴の一つが、垂直方向のスライドです。これは、あるトピックについてより深く掘り下げたり、補足的な情報を提供したりする際に非常に有効です。垂直スライドを作成するには、<section>要素の中にさらに複数の<section>要素をネストします 3。HTML<div class="reveal">
  <div class="slides">
    <section>水平スライド 1</section>
    <section>
      <section>垂直スライド 2.1 (メイン)</section>
      <section>垂直スライド 2.2 (詳細1)</section>
      <section>垂直スライド 2.3 (詳細2)</section>
    </section>
  </div>
</div>
この構造により、プレゼンテーションは二次元的に展開されます。左右の矢印キーで水平スライド間を移動し、上下の矢印キーで垂直スライド間を移動します。スペースキーを押すと、全ての垂直スライドを含めて線形に進みます 26。この二次元的な構成は、情報を階層的に整理し、聴衆の理解を助ける強力な手法です。PowerPointの厳密な線形モデルとは一線を画す、Reveal.jsの重要な概念です 1。設定の詳細: Reveal.initialize()プレゼンテーションの挙動は、JavaScriptのReveal.initialize()メソッドに渡す設定オブジェクトによって細かく調整できます 21。JavaScript<script src="dist/reveal.js"></script>
<script>
  Reveal.initialize({
    // ナビゲーションコントロールを表示
    controls: true,

    // 進捗バーを表示
    progress: true,

    // URLにスライド番号のハッシュを追加
    history: true,

    // スライドを垂直方向に中央揃え
    center: true,

    // トランジションの種類
    transition: 'slide', // 'fade', 'zoom', 'convex' など

    // プラグインの有効化
    plugins:
  });
</script>
このinitialize()メソッドは、プレゼンテーションの準備が完了したときに解決されるPromiseを返すため、初期化後の非同期処理も記述できます 21。表: 主要な設定オプションとその効果オプションキーデフォルト値説明設定値の例controlstrue画面の右下に表示されるナビゲーション矢印の表示を制御します 27。true, false, 'speaker-only'progresstrue画面下部に表示されるプレゼンテーションの進捗バーの表示を制御します 29。true, falsehistoryfalseスライドが変更されるたびにブラウザの履歴にエントリを追加し、URLのハッシュを更新します 27。true, falsecentertrueスライドのコンテンツを垂直方向に中央揃えにするかどうかを指定します 27。true, falsetransition'slide'スライド間のデフォルトのトランジション効果を指定します 27。'none', 'fade', 'slide', 'convex', 'concave', 'zoom'slideNumberfalse現在のスライド番号を表示します。書式も指定可能です 27。true, false, 'h.v', 'c/t'loopfalse最後のスライドから最初のスライドへループするかどうかを指定します 27。true, falsenavigationMode'default'垂直スライドがある場合のナビゲーション挙動を定義します 27。'default', 'linear', 'grid'Part II: コンテンツとビジュアルの作成第4章: スライドのコンテンツ作成: 主要な要素テキストとレイアウト標準的なHTML要素を使用して、スライドにテキストコンテンツを追加します。見出しには<h1>や<h2>、段落には<p>、引用には<blockquote>を使用します 1。Reveal.jsは、コンテンツのレイアウトを補助するための便利なCSSクラスを提供しています。r-fit-text: テキストをスライドの幅に合わせて自動的に最大サイズに調整します。大きな見出しなどに最適です 1。r-stack: 複数の要素を中央揃えで重ねて配置します。後述するフラグメント機能と組み合わせることで、要素を段階的に表示するのに役立ちます 30。r-stretch: 画像や動画などの要素を、スライド内の残りの垂直スペースを埋めるようにリサイズします 30。r-frame: 要素の周りに装飾的なフレームを追加し、背景から際立たせます 30。メディアの統合画像: 標準の<img>タグを使用して、ローカルまたはリモートの画像を簡単に埋め込めます 3。動画と音声: <video>および<audio>タグを使用します。スライドが表示されたときに自動再生させるにはdata-autoplay属性を追加します。また、autoPlayMedia設定オプションで全メディアの自動再生をグローバルに制御することも可能です 32。IFrame: <iframe>タグを使用して、YouTube動画やGoogleスプレッドシートなどの外部Webコンテンツを埋め込めます 32。コンテンツの読み込みを遅延させるdata-src属性や、スライドの表示・非表示をIFrameに通知するpostMessage API (slide:start, slide:stop) もサポートされています 32。データの構造化: リストとテーブル順序なしリスト (<ul>) と順序付きリスト (<ol>) を使用して、情報を箇条書きで整理できます 1。標準的なHTMLの<table>, <tr>, <th>, <td>タグを使用して、表形式のデータを表示できます 1。高度なコンテンツ: コードと数式コードブロック: <pre><code>タグでコードを囲むことで、シンタックスハイライトが適用されます 1。これはデフォルトで有効になっているHighlight.jsプラグインによるものです。class="language-python"のように言語を指定したり、data-line-numbersで行番号を表示したり、data-line-numbers="1,5-7"のように特定の行をハイライトしたりできます 13。さらに、|（パイプ）記号を使ってdata-line-numbers="1|2-3|4"のように記述することで、ハイライト箇所を段階的に表示することも可能です 33。数式: Mathプラグインを有効にすることで、LaTeX形式の数式を美しくレンダリングできます 1。プラグインを初期化する際に、数式を処理するライブラリとしてKaTeX、MathJax 2、MathJax 3から選択します 34。インライン数式は$...$、ディスプレイ数式は$$...$$で囲んで記述します 22。一般的に、KaTeXはMathJaxよりも高速に動作しますが、サポートするLaTeXの機能範囲が若干狭い場合があります。多くのユーザーにとっては、パフォーマンスの観点からKaTeXが推奨されています 34。例: アインシュタインの質量とエネルギーの等価性を示す有名な方程式は、$$E = mc^2$$ と記述することで、次のように表示されます: 第5章: Markdownによる効率的なスライド作成HTMLを直接記述する代わりに、より簡潔なMarkdown記法でスライドコンテンツを作成することが可能です。これにより、コンテンツそのものに集中し、迅速にプレゼンテーションを構築できます。Markdownプラグイン: セットアップと設定Markdownのサポートは、コア機能ではなく、RevealMarkdownという組み込みプラグインによって提供されます 12。使用するには、プラグインのスクリプトファイルを読み込み、Reveal.initialize()の設定でプラグインを登録する必要があります。HTML<script src="plugin/markdown/markdown.js"></script>
<script>
  Reveal.initialize({
    plugins:
  });
</script>
内部的にはmarked.jsというライブラリがMarkdownの解析を行っており、その挙動をカスタマイズすることも可能です 36。スライドの記述: インライン vs. 外部ファイルインライン: <section>要素にdata-markdown属性を付け、その中に<textarea data-template>を配置してMarkdownを直接記述します 6。HTML<section data-markdown>
  <textarea data-template>
    ## Markdownスライド
    - 箇条書き1
    - 箇条書き2
  </textarea>
</section>
外部ファイル: data-markdown="path/to/slides.md"のように、外部の.mdファイルへのパスを指定することもできます 4。この方法を利用する場合、前述の通り、ローカルWebサーバーでの実行が必須となります 36。構造の制御: スライド区切り文字外部のMarkdownファイルを使用する場合、スライドの区切りを定義する必要があります。data-separator: 水平スライドの区切り文字を正規表現で指定します。デフォルトは---（ハイフン3つ）です 4。data-separator-vertical: 垂直スライドの区切り文字を正規表現で指定します。デフォルトは無効ですが、一般的に--（ハイフン2つ）が使われます 4。data-separator-notes: スピーカーノートの開始を示す正規表現を指定します。デフォルトは^Note:です 36。HTML<section data-markdown="presentation.md"
         data-separator="^\n---\n$"
         data-separator-vertical="^\n--\n$"
         data-separator-notes="^Note:">
</section>
高度なMarkdown: 属性の適用Markdownの簡潔さとHTMLの強力な属性指定を両立させるため、Reveal.jsはHTMLコメントを利用した独自の構文を提供しています。これは、Markdownを使いながらフラグメントやスライドごとの背景設定といった高度な機能を実現するための非常に重要なテクニックです。要素への属性追加: Markdown要素の直後に``という形式のコメントを記述することで、その要素（例: <li>や<p>）にHTML属性を追加できます 36。最初の項目 - 次の項目スライドへの属性追加: スライドの先頭に``という形式のコメントを記述することで、そのスライド全体を囲む<section>要素に属性を追加できます 36。このスライドの背景は水色になります第6章: ビジュアルのカスタマイズ: テーマと背景組み込みテーマの適用Reveal.jsには、プレゼンテーションの見た目を一瞬で変更できる、洗練されたテーマが多数組み込まれています 6。テーマを適用するには、index.html内で読み込むテーマ用CSSファイルのファイル名を変更するだけです 37。HTML<link rel="stylesheet" href="dist/theme/white.css">
表: 組み込みReveal.jsテーマテーマ名プレビュー説明black (デフォルト)!(https://revealjs.com/images/docs/themes/black.png)黒背景、白テキスト、青リンクwhite!(https://revealjs.com/images/docs/themes/white.png)白背景、黒テキスト、青リンクleague灰色背景、白テキスト、青リンクbeige!(https://revealjs.com/images/docs/themes/beige.png)ベージュ背景、濃いテキスト、茶色リンクsky!(https://revealjs.com/images/docs/themes/sky.png)青背景、細い濃いテキスト、青リンクnight黒背景、太い白テキスト、オレンジリンクserif!(https://revealjs.com/images/docs/themes/serif.png)カプチーノ背景、灰色テキスト、茶色リンクsimple!(https://revealjs.com/images/docs/themes/simple.png)白背景、黒テキスト、青リンクsolarized!(https://revealjs.com/images/docs/themes/solarized.png)クリーム色背景、濃緑テキスト、青リンクblood!(https://revealjs.com/images/docs/themes/blood.png)濃い背景、太い白テキスト、赤リンクmoon濃紺背景、太い灰色テキスト、青リンクdracula!(https://revealjs.com/images/docs/themes/dracula.png)Draculaカラースキームに基づいたダークテーマテーマのカスタマイズ既存のテーマを微調整したり、独自のテーマを作成したりすることも可能です。CSSカスタムプロパティ: 各テーマは、主要な色やフォントなどをCSSカスタムプロパティ（変数）として公開しています。:root疑似クラスでこれらの変数を上書きすることで、簡単にテーマをカスタマイズできます 37。SCSS: より高度なカスタマイズを行いたい場合、テーマのソースファイルであるSCSSファイルを編集して、独自のテーマを構築できます 2。ダイナミックな背景スライドごとに背景を動的に設定することで、視覚的に豊かなプレゼンテーションを作成できます。これには、<section>要素のdata-background系の属性を使用します 1。色: data-background-color属性に、CSSで有効な任意の色（#dddddd, rgb(70, 70, 255)など）を指定します 8。グラデーション: data-background-gradient属性で、線形または放射状のグラデーションを指定します 40。画像: data-background-image属性で画像のURLを指定します。さらに、data-background-size (例: cover, contain), data-background-repeat (例: no-repeat), data-background-position, data-background-opacity（透明度）といったオプションで表示方法を細かく制御できます 1。動画: data-background-video属性で動画ファイルを指定します。data-background-video-loop（ループ再生）やdata-background-video-muted（ミュート）オプションも利用可能です 13。IFrame: data-background-iframe属性で外部のWebページを背景として埋め込めます。埋め込んだページを操作可能にするには、data-background-interactive属性を追加する必要があります 1。高度な背景テクニックパララックス効果: Reveal.initializeの設定でparallaxBackgroundImageとparallaxBackgroundSizeを指定することで、スクロールに応じて背景がずれるパララックス効果を実装できます 1。背景のトランジション: スライド自体のトランジションとは別に、背景だけのトランジション効果を指定できます。グローバルにはbackgroundTransition設定オプションを、スライドごとにはdata-background-transition属性を使用します 6。Part III: 高度なインタラクティビティと機能第7章: スライドに命を吹き込む: トランジションとアニメーションスライドトランジションスライド間の切り替え効果は、プレゼンテーションの印象を大きく左右します。種類: none (なし), fade (フェード), slide (スライド、デフォルト), convex (凸型), concave (凹型), zoom (ズーム) といった効果が利用可能です 1。グローバル設定: Reveal.initializeのtransitionオプションで、プレゼンテーション全体のデフォルト効果を設定します 27。個別設定: <section>要素にdata-transition="zoom"のように属性を追加することで、特定のスライドの効果を上書きできます 14。速度: transition-speedオプション（グローバル）またはdata-transition-speed属性（個別）で、速度をdefault, fast, slowから選択できます 14。In/Out分離: data-transition="slide-in fade-out"のように、スライドインとスライドアウトで異なる効果を適用することも可能です 14。Auto-AnimateAuto-Animateは、隣り合う2つのスライド間で、一致する要素を自動的かつ滑らかにアニメーションさせる強力な機能です 1。基本: 連続する2つの<section>要素にdata-auto-animate属性を追加するだけで有効になります。アニメーション対象: Reveal.jsは、要素のテキスト内容や構造から一致する要素を自動的に見つけ出し、位置、サイズ、色、不透明度など、アニメーション可能なほとんどのCSSプロパティを遷移させます 45。明示的なマッチング: 自動マッチングがうまく機能しない場合、アニメーションさせたい要素ペアに同じdata-id属性を与えることで、明示的に関連付けることができます 45。設定: autoAnimateEasing (イージング関数) や autoAnimateDuration (アニメーション時間) などのオプションで、アニメーションの挙動をグローバルに調整できます 27。フラグメント: コンテンツの段階的表示フラグメントは、スライド内の要素を一つずつ段階的に表示または強調するための機能です。PowerPointの箇条書きアニメーションに似ていますが、任意のHTML要素に適用できるため、はるかに柔軟です。基本: 表示を制御したい要素にclass="fragment"を追加します。デフォルトでは、要素は最初は非表示で、次に進む操作でフェードインします 3。アニメーションスタイル: fade-up (下からフェードイン), grow (拡大), shrink (縮小), highlight-red (赤くハイライト) など、多彩な効果がクラスとして用意されています。これらをfragmentクラスと共に追加することで、様々な表現が可能になります 1。表示順序の制御: デフォルトではDOMに現れる順に表示されますが、data-fragment-index属性を使って表示順序を自由に制御できます。同じインデックスを持つ要素は同時に表示されます 3。ネスト: フラグメントを入れ子にすることで、一つの要素に複数の効果を連続して適用することも可能です（例: フェードイン → 赤くハイライト → フェードアウト）46。カスタムエフェクト: 独自のCSSを定義することで、オリジナルのフラグメント効果を作成することもできます 46。表: フラグメントのアニメーションスタイルと効果クラス名効果の説明fade-inフェードインして表示されます（デフォルト）。fade-out最初は表示されており、次のステップでフェードアウトします。fade-up下からスライドしながらフェードインします。fade-down上からスライドしながらフェードインします。fade-left左からスライドしながらフェードインします。fade-right右からスライドしながらフェードインします。grow拡大しながら表示されます。shrink縮小しながら表示されます。strike取り消し線が引かれます。highlight-redテキストが赤色にハイライトされます（green, blueも利用可）。fade-in-then-outフェードインし、次のステップでフェードアウトします。fade-in-then-semi-outフェードインし、次のステップで半透明になります。第8章: プラグインエコシステム: コア機能の拡張Reveal.jsの真価は、その拡張性にあります。プラグインを利用することで、コアライブラリにはない様々な機能を追加できます。プラグインの登録と使用方法プラグインを利用するには、通常2つのステップが必要です 12。スクリプトの読み込み: index.html内で、プラグインのJavaScriptファイルを<script>タグで読み込みます。初期化時の登録: Reveal.initialize()の設定オブジェクト内にあるplugins配列に、プラグインのオブジェクトを追加します。JavaScript// 例: MarkdownとHighlightプラグインを有効化
Reveal.initialize({
  plugins:
});
ESモジュールとして提供されているプラグインもあり、その場合はimport構文で利用します 12。組み込みプラグインの詳細Reveal.jsには、よく使われる機能のためのプラグインが標準で同梱されています。Speaker Notes (RevealNotes): スピーカービューを有効にします。<aside class="notes">タグやdata-notes属性でノートを記述し、「S」キーでスピーカービューウィンドウを開きます 48。Search (RevealSearch): CTRL+Shift+F（またはCMD+Shift+F）キーで、プレゼンテーション内のテキストを全文検索する機能を追加します 12。Zoom (RevealZoom): Alt+クリック（LinuxではCtrl+クリック）で、スライド上の任意の要素をズームイン・ズームアウトする機能を追加します 1。Markdown (RevealMarkdown): Markdownによるスライド記述を可能にします（第5章で詳述）。Highlight (RevealHighlight): コードブロックのシンタックスハイライトを提供します（第4章で詳述）。Math (RevealMath): LaTeXによる数式表示を可能にします（第4章で詳述）。広大なエコシステムの探求組み込みプラグイン以外にも、コミュニティによって開発された数多くのサードパーティ製プラグインが存在します 51。これらを利用することで、プレゼンテーションの可能性はさらに広がります。表: 主要な組み込み・サードパーティプラグインプラグイン名種類説明主な機能Notes組み込みスピーカービュー機能を追加します 12。ノート、タイマー、次スライドプレビューSearch組み込みプレゼンテーション内の全文検索機能を追加します 12。CTRL+Shift+Fでの検索Zoom組み込み要素のズーム機能を追加します 12。Alt/Ctrl+クリックでのズームChalkboardサードパーティスライド上に手書きで注釈を描き込めます 51。ライブアノテーション、黒板モードMenuサードパーティプレゼンテーションにナビゲーションメニューを追加します 14。スライドへのジャンプ、テーマ変更AnimateサードパーティSVGを利用した複雑なアニメーションを可能にします 51。SVGアニメーションの制御Quarto Pointerサードパーティ発表中にカーソルをポインタースタイルに変更します 52。マウスカーソルの強調第9章: プレゼンテーションの実施とエクスポートスピーカービュースピーカービューは、発表者にとって非常に強力なツールです。メインのプレゼンテーション画面とは別のウィンドウで、以下の情報を表示します 1。現在のスライド次のスライドのプレビュー各スライドに設定されたスピーカーノート経過時間を示すタイマーこの機能は、プレゼンターが聴衆の画面とは異なる情報を手元で確認できるため、スムーズな発表を支援します。ただし、この機能は内部的にWebSocketを使用するため、Full Setupなどで提供されるローカルWebサーバー環境が必要です 17。また、defaultTimingやtotalTimeを設定することで、発表のペースを管理するためのペーシングタイマーも利用できます 48。さらに、reveal-notes-serverという別のプラグインを使えば、スマートフォンなどの別デバイスでスピーカーノートを表示することも可能です 55。PDFへのエクスポート作成したプレゼンテーションは、配布やバックアップのためにPDF形式にエクスポートできます。このプロセスは、ブラウザの印刷機能と特別な印刷用スタイルシートを巧妙に利用したものです 6。手順:プレゼンテーションのURLの末尾に?print-pdfを追加してアクセスします（例: http://localhost:8000/?print-pdf）57。ブラウザの印刷ダイアログを開きます（Ctrl/Cmd + P）。以下の設定を行います 57。送信先: PDFとして保存レイアウト: 横余白: なし背景のグラフィック: 有効にする保存ボタンをクリックします。この機能はブラウザの印刷エンジンに依存するため、公式にはGoogle ChromeおよびChromiumでのみ動作が確認されています 57。エクスポートオプション:スピーカーノートの含入: Reveal.initializeの設定でshowNotes: trueとすると、スライド上にオーバーレイとしてノートが印刷されます。showNotes: 'separate-page'とすると、各スライドの後にノートが別ページとして印刷されます 57。フラグメントの扱い: デフォルトでは、フラグメントの各ステップが個別のページとして印刷されます。これを無効にし、全てのフラグメントが表示された最終状態を1ページにまとめたい場合は、pdfSeparateFragments: falseを設定します 57。Part IV: 統合とデプロイ第10章: Reveal.jsをモダンなワークフローに統合するReactでの利用Reactのような仮想DOMベースのフレームワーク内で、直接DOMを操作するReveal.jsを統合するには、いくつかのベストプラクティスがあります 59。useEffectフックの利用（推奨）: コンポーネントがマウントされ、DOM要素が実際にレンダリングされた後にReveal.jsを初期化するため、useEffectフック内でReveal.initialize()を呼び出します。useRefフックを使ってdeckインスタンスへの参照を保持し、不要な再初期化を防ぐことが重要です 59。React Portalsの利用: Reveal.jsのメイン構造はReactの管理外に置き、特定のスライド内にReactコンポーネントを埋め込みたい場合にPortalsを利用する方法です 59。ラッパーライブラリ: revealjs-reactのようなサードパーティ製のラッパーライブラリを利用することで、セットアッププロセスを抽象化し、よりReactらしい方法でプレゼンテーションを構築することも可能です 59。データサイエンスツールでの利用: QuartoとR MarkdownQuartoやR Markdownといったツールは、Reveal.jsをプレゼンテーション出力形式の一つとしてサポートしています。これにより、データサイエンティストや研究者は、使い慣れたMarkdown記法で、実行可能なコードチャンクを含むプレゼンテーションを作成できます 13。ファイルの先頭にあるYAMLヘッダーでformat: revealjsと指定し、テーマやトランジションなどのオプションを設定します 13。このワークフローの最大の利点は、分析スクリプトから生成されたコード、プロット、数式を、シームレスに美しくインタラクティブなプレゼンテーションに直接埋め込める点です 13。開発者ツール: VS Code拡張機能 (vscode-reveal)vscode-revealは、Visual Studio Code内でReveal.jsプレゼンテーションを効率的に作成するための拡張機能です 15。ライブプレビュー: Markdownでスライドを編集しながら、リアルタイムでプレビューを横に表示できます。スライド概要: サイドバーにスライドのタイトル一覧が表示され、簡単にナビゲーションできます。YAML Front Matter: Reveal.jsの設定オプションを、Markdownファイル上部のYAMLヘッダーで直接記述・管理できます。エクスポート: コマンド一つでPDFや静的HTMLサイトへのエクスポートが可能です。この拡張機能は、Markdownベースのプレゼンテーション作成ワークフローを大幅に効率化します 15。第11章: プレゼンテーションをWebにデプロイする作成したHTMLベースのプレゼンテーションは、静的サイトとして簡単にWeb上に公開できます。GitHub PagesでのホスティングGitHub Pagesは、GitHubリポジトリから直接Webサイトをホスティングできる無料のサービスで、Reveal.jsプレゼンテーションの公開に最適です 39。リポジトリの作成: GitHub上に新しいパブリックリポジトリを作成します。ファイルのプッシュ: index.htmlやdist/, plugin/ディレクトリなど、プレゼンテーションを構成する全てのファイルをリポジトリのmain（またはmaster）ブランチにプッシュします。GitHub Pagesの設定: リポジトリの「Settings」タブに移動し、「Pages」セクションで、デプロイ元のブランチとしてmainブランチを選択し、保存します。公開: しばらくすると、https://<ユーザー名>.github.io/<リポジトリ名>/というURLでプレゼンテーションが公開されます。その他のデプロイ戦略Firebase Hosting 63、Netlify、Vercelといった他の静的ホスティングサービスも同様に利用できます。基本的なプロセスは同じで、静的なファイル群をサービスにアップロードまたはGitリポジトリと連携させるだけです。これらのサービスは、カスタムドメインの設定や、より高度なデプロイ機能を提供している場合があります。最終的な推奨事項とベストプラクティスプレゼンテーションを完成させ、公開する前の最終チェックリストです。画像の最適化: ファイルサイズを削減し、読み込み速度を向上させます。テーマの選定: コンテンツの雰囲気に合ったテーマを選択し、一貫性を保ちます。スピーカービューでの練習: タイマーやノート機能を活用して、発表のリハーサルを行います。PDFバックアップの作成: インターネット接続がない場合や、配布用にPDF版を生成しておきます。結論Reveal.jsは、単なるスライド作成ツールではなく、プレゼンテーションを「コード」として扱うという新しいパラダイムを提供する強力なフレームワークです。HTML、CSS、JavaScriptというWebの標準技術を基盤とすることで、従来のWYSIWYGツールでは実現不可能なレベルのカスタマイズ性、インタラクティビティ、そしてバージョン管理との親和性を実現します。本レポートで詳述したように、その柔軟性は多岐にわたります。簡単なダウンロードで始められるBasic Setupから、開発サーバーを備えたFull Setup、Dockerによるコンテナ化、そしてCDNを利用した軽量なセットアップまで、ユーザーの技術レベルやプロジェクトの要件に応じて最適な環境を選択できます。コンテンツ作成においても、HTMLによる完全な制御と、Markdownによる迅速な記述という二つのアプローチが用意されており、特に後者は技術文書との親和性が非常に高いです。テーマ、背景、トランジション、フラグメント、Auto-Animateといった豊富な視覚的・動的表現機能は、聴衆の注意を引きつけ、複雑な情報を効果的に伝えるための強力な武器となります。さらに、検索、スピーカーノート、数式サポートといった機能を標準プラグインとして提供し、広大なサードパーティ製プラグインのエコシステムによってその能力を無限に拡張できる点は、Reveal.jsが単なるライブラリではなく、成熟したプラットフォームであることを示しています。しかし、この強力な柔軟性は、Web技術に関する一定の知識を要求するというトレードオフを伴います。そのため、Reveal.jsは全てのユーザーにとっての最適解ではありません。非技術者との共同編集が頻繁に発生する場合や、迅速なドラッグ＆ドロップでの作成が求められる場面では、依然としてGoogle SlidesやPowerPointに軍配が上がります。結論として、Reveal.jsは以下のようなユーザープロファイルに最も適したツールであると言えます。Web開発者、データサイエンティスト、研究者、教育者など、技術的な内容を扱う専門家。プレゼンテーションのデザインや挙動を細部まで制御したいと考えるクリエイター。Gitを用いてプレゼンテーションの変更履歴を厳密に管理したいと考える個人またはチーム。コードスニペット、インタラクティブなデモ、数式などを多用する発表者。Reveal.jsを選択するということは、学習コストと引き換えに、表現の自由とコンテンツの永続性を手に入れることを意味します。適切に活用すれば、それは単なる情報の伝達手段を超え、記憶に残る体験を創造するための強力な表現媒体となるでしょう。